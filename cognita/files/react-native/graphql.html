<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>What is GraphQL?</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../index.js"></script>
</head>
<body>
    <header>
        <nav class="corporate-nav">
            <div class="nav-container">
                <div class="title-header">
                    <h1 class="title">What is GraphQL?</h1>
                    <p class="subtitle">GraphQL is a query language for APIs and a runtime for executing those queries with your existing data. It was developed by Facebook in 2012 and publicly released in 2015.</p>
                </div>        
            </div>
        </nav>
    </header>

    <main>
        <section>
            <h2>How is it different from REST?</h2>
            <ul>
                <li>REST has multiple endpoints (URLs) for different resources (like /users, /posts, /comments).</li>
                <li>GraphQL exposes a single endpoint that you send queries to, specifying exactly what data you want.</li>
            </ul>
        </section>

        <section>
            <h2>Key features of GraphQL:</h2>
            <ol>
                <li>
                    Ask for exactly what you need
                    <p>Instead of getting a fixed structure, clients request only the fields they want, reducing over-fetching and under-fetching of data.</p>
                </li>

                <li>
                    Get many resources in a single request
                    <p>You can get related data (e.g., user + their posts + comments) in one query instead of multiple REST calls.</p>
                </li>

                <li>
                    Strongly typed schema
                    <p>The API defines types for data, which enables validation, introspection, and better tooling support.</p>
                </li>

                <li>
                    Real-time updates (via subscriptions)
                    <p>GraphQL supports subscriptions so clients can receive real-time updates.</p>
                </li>
            </ol>
        </section>

        <section>
            <h2>How a GraphQL query looks:</h2>
            <pre><code>
query {
    user(id: "123") {
        id
        name
        email
        posts {
            id
            title
        }
    }
}                  
            </code></pre>
            <p>This query asks for a user by ID and fetches their basic info plus their posts.</p>
        </section>

        <section>
            <h2>Benefits:</h2>
            <ul>
                <li>More efficient data fetching</li>
                <li>Better developer experience with auto-generated docs and validation</li>
                <li>Flexible and evolvable APIs</li>
            </ul>
        </section>

        <section>
            <h2>Summary:</h2>
            <p>GraphQL lets clients ask APIs for exactly what they want in a single request, improving efficiency and flexibility compared to traditional REST APIs.</p>
        </section>

        <section>
            <p>Integrating a GraphQL API in React Native usually involves using a client library like Apollo Client or Relay.</p>
            <p>The most popular and straightforward choice is Apollo Client. Here’s a simple guide on how to set it up and use it in React Native:</p>
        </section>

        <section>
            <h2>1. Install Apollo Client & dependencies</h2>
            <p>Run this in your React Native project directory:</p>
            <pre><code>
npm install @apollo/client graphql
            </code></pre>

            <p>or if you use yarn:</p>

            <pre><code>
yarn add @apollo/client graphql
            </code></pre>
        </section>

        <section>
            <h2>2. Set up Apollo Client</h2>
            <p>Create an Apollo Client instance pointing to your GraphQL server URL.</p>
            <pre><code>
// ApolloClientSetup.js
import { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';

const client = new ApolloClient({
  link: new HttpLink({
    uri: 'https://your-graphql-api.com/graphql', // Replace with your API URL
  }),
  cache: new InMemoryCache(),
});

export default client;
            </code></pre>
        </section>

        <section>
            <h2>3. Wrap your app with ApolloProvider</h2>
            <p>In your entry point (usually App.js), wrap your app in the ApolloProvider so every component can use the client.</p>

            <pre><code>
// App.js
import React from 'react';
import { ApolloProvider } from '@apollo/client';
import client from './ApolloClientSetup';
import MainComponent from './MainComponent';

export default function App() {
  return (
    &lt;ApolloProvider client={client}&gt;
        &lt;MainComponent /&gt;
    &lt;/ApolloProvider&gt;
  );
}
            </code></pre>
        </section>

        <section>
            <h2>4. Write a sample query and fetch data</h2>
            <p>Use the useQuery hook from Apollo Client to fetch data inside your components.</p>

            <pre><code>
import React from 'react';
import { View, Text, ActivityIndicator } from 'react-native';
import { gql, useQuery } from '@apollo/client';

const GET_USERS = gql`
  query {
    users {
      id
      name
      email
    }
  }
`;

export default function MainComponent() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return &lt;ActivityIndicator /&gt;;
  if (error) return &lt;Text&gt;Error: {error.message}&lt;/Text&gt;;

  return (
    &lt;View&gt;
      {data.users.map(user => (
        &lt;Text key={user.id}>{user.name} - {user.email}&lt;/Text&gt;
      ))}
    &lt;/View&gt;
  );
}
            </code></pre>
        </section>

        <section>
            <h2>Summary:</h2>
            <ul>
                <li>Install Apollo Client and graphql.</li>
                <li>Setup Apollo Client with your GraphQL endpoint.</li>
                <li>Wrap your app with ApolloProvider.</li>
                <li>Use Apollo hooks (useQuery, useMutation) to interact with your API.</li>
            </ul>
        </section>

        <section>
            <h2>Key concepts of REST APIs</h2>
            <p>Let's try to understand the concepts of REST. </p>
            <p><b>Statelessness</b></p>
            <p>Each interaction between the client and the server is independent. The server does not store any session data related to the client between requests, which means that every request from a client to a server must contain all the information needed to understand and process that request.</p>

            <p><b>Resource-based</b></p>
            <p>Every piece of data or functionality is treated as a resource that can be identified and manipulated through a unique identifier, typically a URI (Uniform Resource Identifier). </p>
            <p>For example, in an e-commerce application, resources might include customers, products, orders, etc. Every resource is identified by a unique URI that acts like an address where the resource can be accessed. For example:</p>
            <ul>
                <li>/products might refer to the collection of all products.</li>
                <li>/products/123 might refer to a specific product with the ID 123.</li>
            </ul>
        </section>

        <section>
            <h2>HTTP methods</h2>
            <p>RESTful APIs typically use standard HTTP methods to perform operations on resources:</p>
            <ul>
                <li>GET: Retrieve data from a server (e.g., fetch a list of products).</li>
                <li>POST: Submit data to the server (e.g., create a new product).</li>
                <li>PUT: Update an existing resource (e.g., modify product details).</li>
                <li>DELETE: Remove a resource (e.g., delete a product).</li>
            </ul>

            <p>A standard GET request would look like this:</p>
            <p>Request:</p>
            <p>GET api/users/1</p>

            <p>Response:</p>
            <pre>
                <code>
{
    "id": 1
    "firstName": Joe
    "lastName": Smith
    "birthYear": 1987
}
                </code>
            </pre>

            <p>Data Formats</p>
            <p>A RESTful API can use different formats to represent and exchange data, including JSON, XML, HTML, Plain Text, YAML, and CSV.</p>
        </section>

        <section>
            <h2>What Is GraphQL?</h2>
            <p>GraphQL is an open-source query language and runtime for APIs that allows clients to request exactly the data they need, and nothing more. It was originally developed internally by Meta (previously Facebook) in 2012 to optimize data fetching for their mobile applications and released for public use in 2015. </p>
        
            <p>Key concepts of GraphQL APIs</p>
            <p>Let's look at the main ideas with GraphQL.</p>

            <p>Client-specific queries</p>
            <p>In GraphQL, clients define the structure of the response by specifying the fields they need in their queries. This means that the client can request only the specific data it requires, avoiding over-fetching (receiving too much data) and under-fetching (receiving insufficient data).</p>
        
            <p>In GraphQL, a query to get a user’s detail would look like this:</p>
            <p>Request:</p>
            <pre>
                <code>
POST /graphql

query {
    user(id:1) {
        id
        firstName
        lastName
    }
}
                </code>
            </pre>

            <p>Response:</p>
            <pre><code>
{
    "user": {
        "id": 1
        "firstName": "Joe"
        "lastName": "Smith"
    }
}
            </code></pre>
        </section>

        <section>
            <h2>Queries vs. mutations</h2>
            <p>While queries are used to read data, mutations are used to write or modify data. Mutations in GraphQL are analogous to the POST, PUT, and DELETE operations in REST.</p>
        </section>

        <section>
            <h2>Single endpoint</h2>
            <p>Unlike REST APIs, which might have multiple endpoints for different resources, a GraphQL API typically exposes a single endpoint. This endpoint handles all the queries and mutations, making it simpler for clients to interact with the API.</p>
        </section>

        <section>
            <h2>Strongly typed schema</h2>
            <p>GraphQL APIs are defined by a schema, which is a strongly typed definition of the data models available, and the relationships between them. This schema serves as a contract between the client and the server, ensuring that the data returned matches the client's request and is of the expected type.</p>
        </section>

        <section>
            <h2>Introspection</h2>
            <p>The GraphQL schema is self-documenting. Clients can use the introspection feature to query the schema itself and discover the types, queries, mutations, and subscriptions available, making it easier to explore and understand the API.</p>
        </section>

        <section>
            <h2>Real-time data</h2>
            <p>GraphQL supports real-time data updates through subscriptions. Subscriptions allow clients to receive updates whenever the data they are interested in changes, which is useful for real-time applications like chat apps or live feeds.</p>
        </section>

        <section>
            <h2>Key Differences Between GraphQL and REST</h2>
            <p>The table below summarizes the key differences between GraphQL and REST APIs.</p>
            <table>
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>REST</th>
                        <th>GraphQL</th>
                    </tr>
                </thead>
                <tbody>
                    <thead>
                        <tr>
                            <td>Nature</td>
                            <td>Architectural</td>
                            <td>Query language</td>
                        </tr>
                        <tr>
                            <td>Data Fetching</td>
                            <td>Multiple endpoints for different resources (/products/123, /users/userA, etc.)</td>
                            <td>Single endpoint with flexible queries.</td>
                        </tr>
                        <tr>
                            <td>Versioning</td>
                            <td>Typically versioned via the URL (e.g., /api/v1/).</td>
                            <td>No versioning; changes are managed by evolving the schema while maintaining compatibility.</td>
                        </tr>
                        <tr>
                            <td>Data Types</td>
                            <td>Not strictly defined; clients may receive varying data formats.</td>
                            <td>Strongly typed schema that defines the data structure and types explicitly.</td>
                        </tr>
                        <tr>
                            <td>Error Handling</td>
                            <td>HTTP status codes are used to indicate errors.</td>
                            <td>Errors returned within the response body. Still uses HTTP status codes.</td>
                        </tr>
                    </thead>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Advantages and Disadvantages of GraphQL and REST</h2>
            <table>
                <thead>
                    <tr>
                        <th>API Type</th>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>REST</td>
                        <td>
                            <p>- Easy to learn: Familiar to developers with web experience.</p>
                            <p>- Mature tooling: Extensive documentation and security practices (OAuth, API keys).</p>
                        </td>
                        <td>
                            <p>- Over/under-fetching: Can lead to inefficient data retrieval.</p>
                            <p>- Versioning: Requires multiple API versions.</p>
                            <p>- No native real-time updates: Needs additional tech like WebSockets.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>GraphQL</td>
                        <td>
                            <p>- Efficient data fetching: Single request retrieves only needed data.</p>
                            <p>- Self-documenting: Schema automatically serves as up-to-date documentation.</p>
                            <p>- Real-time updates: Supports subscriptions for instant synchronization.</p>
                        </td>
                        <td>
                            <p>- Steep learning curve: More complex to learn.</p>
                            <p>- Caching complexity: Standard HTTP caching isn’t effective; custom caching is needed.</p>
                            <p>- Security risks: Flexible queries can lead to accidental data exposure.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Choosing Between GraphQL and REST</h2>
            <p>The choice between REST versus GraphQL will depend entirely on your project’s needs. You probably already have an inkling based on the previous section, but as a rule of thumb, you should probably use REST when you have:</p>
            <ul>
                <li>Simple data models</li>
                <li>Applications requiring extensive caching.</li>
                <li>Teams familiar with REST conventions.</li>
                <li>Need for predictable, standardized responses.</li>
            </ul>

            <p>And use GraphQL when you deal with:</p>
            <ul>
                <li>Complex data models with nested relationships.</li>
                <li>Applications needing flexible, dynamic queries.</li>
                <li>Rapid iteration and reduced backend adjustments.</li>
                <li>Real-time updates.</li>
            </ul>

            <p>REST and GraphQL can also be used together in hybrid solutions, so your project can benefit from simple, well-defined REST endpoints but also from the flexibility of GraphQL for more complex data retrieval. For instance, in an e-commerce app, you could use REST for authentication and user registration to benefit from standard security practices like Oauth and use GraphQL to fetch more nested and complex information like product details, categories, and user reviews.</p>
        </section>

        <section>
            <h2>Conclusion</h2>
            <p>So you get it: both GraphQL and REST have their strengths and weaknesses and are suitable for different scenarios. The choice between them should be guided by your project’s requirements and the complexity of your data. </p>
            <p>That said, both tools are really fun to work with and can teach you a lot about data, so if you have the opportunity, I would recommend trying them out at some point!</p>
            <p>And, if after reading this, you know what tool you want to use, then you are ready for the next step! Go check out our <a href="https://www.datacamp.com/blog/mastering-api-design">Mastering API Design: Essential Strategies for Developing High-Performance APIs</a> blog post to learn how to design your own APIs. </p>
            <p>Author</p>
            <p>Marie Fayard</p>
        </section>
    </main>

    <footer>
        <p class="copyright">
            &copy; <span id="year"></span> Aether Corp. All rights reserved.
        </p>
    </footer>
</body>
</html>
