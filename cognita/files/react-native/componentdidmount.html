<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>componentDidMount</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../index.js"></script>
</head>
<body>
    <header>
        <nav class="corporate-nav">
            <div class="nav-container">
                <div class="title-header">
                    <h1 class="title">componentDidMount</h1>
                    <p class="subtitle">The code you posted is a React component lifecycle method (componentDidMount) used in a React Navigation context (likely in a React Native app). It sets up listeners to handle navigation focus and blur events. Here's a breakdown of what it's doing:</p>
                </div>        
            </div>
        </nav>
    </header>

    <main>
        <section>
            <h2>üîç What it does</h2>
            <pre><code>
componentDidMount() {
    this.focusListener = this.props.navigation.addListener('focus', () => {
        if (this._isBackNavigation) {
            this.showLoading(); // Show loading spinner or similar
        }
        this._isBackNavigation = true; // Mark future focus events as back navigations
    });

    // Optional: reset on blur
    this.blurListener = this.props.navigation.addListener('blur', () => {
        // Currently no logic here, but can be used for cleanup
    });
}                
            </code></pre>
        </section>

        <section>
            <h2>üß† Key Concepts</h2>
            <ul>
                <li>focus event: Triggered when the screen comes into focus (i.e., the user navigates to this screen).</li>
                <li>blur event: Triggered when the screen goes out of focus (i.e., user navigates away).</li>
            </ul>
        </section>

        <section>
            <h2>üß© Variables</h2>
            <ul>
                <li>
                    this._isBackNavigation:
                    <p>A flag to determine whether this focus is due to a back navigation (i.e., returning to this screen).</p>
                    <ul>
                        <li>Initially, this would be undefined or false.</li>
                        <li>After the first focus, it's set to true, meaning subsequent focus events will be treated as "coming back" to the screen.</li>
                    </ul>
                </li>
                <li>
                    this.showLoading()
                    <p>A custom method (presumably part of your class) to show a loading indicator.</p>
                </li>
            </ul>
        </section>

        <section>
            <h2>‚úÖ Use Case Example</h2>
            <p>Imagine you have a list screen ‚Üí detail screen ‚Üí user presses "Back" ‚Üí returns to list.</p>
            <p>You want the list to refresh or show a loading indicator only when coming back, not when navigating initially.</p>
        </section>

        <section>
            <h2>‚ö†Ô∏è Suggested Improvements</h2>
            <ol>
                <li>
                    Don't forget to clean up listeners!
                    <p>If you don‚Äôt remove listeners, you could get memory leaks or duplicate event handling</p>
                    <p>Add this in componentWillUnmount():</p>
                    <pre><code>
componentWillUnmount() {
    if (this.focusListener) this.focusListener();
    if (this.blurListener) this.blurListener();
}                          
                    </code></pre>
                </li>
                <li>
                    Initialize _isBackNavigation properly (if not already done):
                    <pre><code>
constructor(props) {
    super(props);
    this._isBackNavigation = false;
}                          
                    </code></pre>
                </li>
            </ol>
        </section>

        <section>
            <h2>üîÑ Modern React (Hooks) Version</h2>
            <p>If you're using functional components with hooks:</p>
            <pre><code>
useFocusEffect(
  useCallback(() => {
    if (isBackNavigationRef.current) {
      showLoading();
    }
    isBackNavigationRef.current = true;
  }, [])
);
            </code></pre>

            <p>And initialize isBackNavigationRef with:</p>
            <pre><code>
const isBackNavigationRef = useRef(false);
            </code></pre>
        </section>

        <section>
            <p>Great follow-up! You're asking whether cleanup is needed in this version using useFocusEffect. The short answer is:</p>
            <p>‚úÖ No, manual cleanup is not required in this case ‚Äî because useFocusEffect automatically handles subscription and cleanup for you.</p>
        
            <h2>üîç Why no manual cleanup?</h2>
            <p>You're using:</p>
            <pre><code>
useFocusEffect(
  useCallback(() => {
    if (isBackNavigationRef.current) {
      showLoading();
    }
    isBackNavigationRef.current = true;
  }, [])
);
            </code></pre>
            <p>This is part of React Navigation's useFocusEffect hook, which is designed to:</p>
            <ul>
                <li>Run your logic when the screen comes into focus.</li>
                <li>Automatically unsubscribe or clean up when the screen loses focus.</li>
            </ul>
        </section>

        <section>
            <h2>‚úÖ Internally, it handles:</h2>
            <ul>
                <li>Adding the listener when the component is focused.</li>
                <li>Removing the listener when blurred or the component unmounts.</li>
            </ul>
        </section>

        <section>
            <h2>üßº What if you do need cleanup?</h2>
            <p>If you do need to perform custom cleanup (like cancelling a request or resetting state), you can return a function inside the callback:</p>
            <pre><code>
useFocusEffect(
  useCallback(() => {
    // Do something on focus
    if (isBackNavigationRef.current) {
      showLoading();
    }
    isBackNavigationRef.current = true;

    // Optional cleanup
    return () => {
      // Cleanup logic on blur/unmount
    };
  }, [])
);
            </code></pre>
            <p>But in your specific case ‚Äî just calling showLoading() conditionally ‚Äî no extra cleanup is needed.</p>
        </section>

        <section>
            <h2>‚úÖ Summary</h2>
            <table>
                <thead>
                    <tr>
                        <th>Concern</th>
                        <th>Handled by useFocusEffect?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Listener cleanup</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                    <tr>
                        <td>Memory leaks</td>
                        <td>‚úÖ Avoided automatically</td>
                    </tr>
                    <tr>
                        <td>Manual cleanup</td>
                        <td>‚ùå Not needed (unless you add side effects like timers, requests, etc.)</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <p>You're working with **useFocusEffect** from React Navigation, which is a very handy hook for running code when a screen is focused (like componentDidFocus) ‚Äî especially useful in functional components.</p>
            <h2>üîß Basic Usage</h2>
            <pre><code>
import { useFocusEffect } from '@react-navigation/native';
import { useCallback } from 'react';

useFocusEffect(
  useCallback(() => {
    // This runs when the screen comes into focus

    return () => {
      // This runs when the screen loses focus (optional cleanup)
    };
  }, [])
);
            </code></pre>
        </section>

        <section>
            <h2>‚úÖ When to use useFocusEffect</h2>
            <p>Use it when you want to:</p>
            <ul>
                <li>Fetch or refresh data each time the screen is focused</li>
                <li>Reset UI state</li>
                <li>Start animations or timers</li>
                <li>Check conditions like whether the user came back to this screen</li>
            </ul>
        </section>

        <section>
            <h2>üÜö Compared to useEffect</h2>
            <table>
                <thead>
                    <tr>
                        <th>useEffect</th>
                        <th>useFocusEffect</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Runs based on component lifecycle or dependency array</td>
                        <td>Runs every time the screen comes into focus</td>
                    </tr>
                    <tr>
                        <td>Doesn't know about navigation state</td>
                        <td>Integrated with React Navigation</td>
                    </tr>
                    <tr>
                        <td>Great for mounting logic</td>
                        <td>Great for focus/blur logic</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>üß† Example: Show Loading on Back Navigation</h2>
            <p>Let‚Äôs say you want to show a loading indicator only when the screen is focused again (i.e. on "back navigation"):</p>
            <pre><code>
import { useFocusEffect } from '@react-navigation/native';
import { useCallback, useRef } from 'react';

function MyScreen() {
  const isBackNavigationRef = useRef(false);

  useFocusEffect(
    useCallback(() => {
      if (isBackNavigationRef.current) {
        // User is returning to this screen
        showLoading();
      }

      // Set the flag so future focus is treated as "back navigation"
      isBackNavigationRef.current = true;

      return () => {
        // Optional: cleanup
      };
    }, [])
  );

  return (
    &lt;View&gt;
      {/* Screen content */}
    &lt;/View&gt;
  );
}
            </code></pre>
        </section>

        <section>
            <h2>üõ† Gotchas</h2>
            <ul>
                <li>useFocusEffect must be called inside the component body (not conditionally).</li>
                <li>Wrap your callback in useCallback to prevent unnecessary re-subscriptions.</li>
                <li>Cleanup (return function) is optional but useful for side effects like timers or subscriptions.</li>
            </ul>
        </section>
    </main>

    <footer>
        <p class="copyright">
            &copy; <span id="year"></span> Aether Corp. All rights reserved.
        </p>
    </footer>
</body>
</html>
