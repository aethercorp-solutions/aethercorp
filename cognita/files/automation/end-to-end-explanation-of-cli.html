<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>end-to-end explanation of CLI (Command Line Interface)</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../index.js"></script>
</head>
<body>
    <header>
        <nav class="corporate-nav">
            <div class="nav-container">
                <div class="title-header">
                    <h1 class="title">end-to-end explanation of CLI (Command Line Interface)</h1>
                    <p class="subtitle">Below is a clear, end-to-end explanation of CLI (Command Line Interface) covering what it is, how it‚Äôs used, how to implement one, and real-world use cases, with practical examples (Node.js-focused, since that matches your background).</p>
                </div>        
            </div>
        </nav>
    </header>

    <main>
        <section>
            <h2>1. What is a CLI?</h2>
            <p>A CLI (Command Line Interface) is a program you run from a terminal by typing commands instead of clicking UI buttons.</p>
            <p>Example:</p>
            <pre><code>
git status
npm install
aws deploy
            </code></pre>

            <p>Each command:</p>
            <ul>
                <li>Accepts arguments (positional values)</li>
                <li>Accepts options/flags (--help, -v)</li>
                <li>Executes logic</li>
                <li>Outputs text (stdout / stderr)</li>
            </ul>
        </section>

        <section>
            <h2>2. Why use a CLI?</h2>
            <p>Advantages</p>
            <ul>
                <li>‚ö° Faster than GUI for repetitive tasks</li>
                <li>ü§ñ Automatable (scripts, CI/CD)</li>
                <li>üåç Works on servers & headless environments</li>
                <li>üîß Perfect for developer tooling</li>
            </ul>

            <p>When CLI is better than UI</p>
            <table>
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>Why CLI</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Deployment</td>
                        <td>Scriptable & repeatable</td>
                    </tr>
                    <tr>
                        <td>Code generation</td>
                        <td>One command creates files</td>
                    </tr>
                    <tr>
                        <td>DevOps tasks</td>
                        <td>Works on servers</td>
                    </tr>
                    <tr>
                        <td>Data processing</td>
                        <td>Batch execution</td>
                    </tr>
                    <tr>
                        <td>Internal tools</td>
                        <td>Faster than building UI</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>3. Common CLI Usage Patterns</h2>
            <p>Basic command</p>
            <pre><code>
mycli init
            </code></pre>

            <p>With arguments</p>
            <pre><code>
mycli create-user paul
            </code></pre>

            <p>With flags</p>
            <pre><code>
mycli deploy --env prod --force
            </code></pre>

            <p>With help</p>
            <pre><code>
mycli --help
mycli deploy --help
            </code></pre>
        </section>

        <section>
            <h2>4. CLI Anatomy (How it Works Internally)</h2>
            <p>Every CLI has these parts:</p>
            <pre><code>
Command
 ‚îú‚îÄ Arguments
 ‚îú‚îÄ Options / Flags
 ‚îú‚îÄ Validation
 ‚îú‚îÄ Business Logic
 ‚îî‚îÄ Output
            </code></pre>

            <p>Example:</p>
            <pre><code>
mycli upload file.txt --public
            </code></pre>

            <ul>
                <li>upload ‚Üí command</li>
                <li>file.txt ‚Üí argument</li>
                <li>--public ‚Üí flag</li>
            </ul>
        </section>

        <section>
            <h2>5. Implementing a CLI (Node.js Example)</h2>
            <p>Step 1: Create CLI entry file</p>
            <pre><code>
mkdir mycli
cd mycli
npm init -y
            </code></pre>

            <p>Create index.js:</p>
            <pre><code>
#!/usr/bin/env node

console.log("Hello from CLI");
            </code></pre>

            <p>Make it executable:</p>
            <pre><code>
chmod +x index.js
            </code></pre>

            <p>Run:</p>
            <pre><code>
node index.js
            </code></pre>

            <p>Step 2: Read CLI arguments</p>
            <pre><code>
const args = process.argv.slice(2);
console.log(args);
            </code></pre>

            <p>Example:</p>
            <pre><code>
node index.js deploy --env prod
            </code></pre>

            <p>Output:</p>
            <pre><code>
["deploy", "--env", "prod"]
            </code></pre>
        </section>
        
        <section>
            <h2>Step 3: Parse commands manually (simple)</h2>
            <pre><code>
const [command, ...rest] = process.argv.slice(2);

if (command === "init") {
  console.log("Initializing project...");
}

if (command === "deploy") {
  console.log("Deploying...");
}
            </code></pre>
        </section>

        <section>
            <h2>6. Using CLI Libraries (Recommended)</h2>
            <p>Popular CLI libraries</p>
            <table>
                <thead>
                    <tr>
                        <th>Library</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>commander</td>
                        <td>Most popular</td>
                    </tr>
                    <tr>
                        <td>yargs</td>
                        <td>Complex argument parsing</td>
                    </tr>
                    <tr>
                        <td>oclif</td>
                        <td>Enterprise-grade CLI</td>
                    </tr>
                    <tr>
                        <td>zx</td>
                        <td>Script-like CLI</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Example: CLI with commander</h2>
            <p>Install:</p>
            <pre><code>
npm install commander
            </code></pre>

            <pre><code>
#!/usr/bin/env node
const { Command } = require("commander");

const program = new Command();

program
  .name("mycli")
  .description("Example CLI tool")
  .version("1.0.0");

program
  .command("deploy")
  .option("-e, --env <env>", "Environment")
  .option("-f, --force", "Force deploy")
  .action((options) => {
    console.log("Deploying to", options.env);
    if (options.force) console.log("Force enabled");
  });

program.parse();
            </code></pre>

            <p>Usage:</p>
            <pre><code>
mycli deploy --env prod --force
            </code></pre>
        </section>

        <section>
            <h2>7. Global Installation (Real CLI Behavior)</h2>
            <p>Add to package.json:</p>
            <pre><code>
{
    "bin": {
        "mycli": "./index.js"
    }
}                  
            </code></pre>

            <p>Install globally:</p>
            <pre><code>
npm install -g .
            </code></pre>

            <p>Now run:</p>
            <pre><code>
mycli deploy
            </code></pre>
        </section>

        <section>
            <h2>8. Real-World CLI Use Cases</h2>
            <p>1Ô∏è‚É£ Project Scaffolding</p>
            <pre><code>
npx create-react-app myapp
            </code></pre>
            <p>Creates folders, config, installs deps.</p>
        </section>

        <section>
            <h2>2Ô∏è‚É£ DevOps & Cloud</h2>
            <pre><code>
aws lambda deploy
serverless deploy
kubectl apply
            </code></pre>
            <p>Used in:</p>
            <ul>
                <li>CI/CD</li>
                <li>Automation</li>
                <li>Server management</li>
            </ul>
        </section>

        <section>
            <h2>3Ô∏è‚É£ Database Tools</h2>
            <pre><code>
mongoimport
prisma migrate
typeorm migration:run
            </code></pre>
        </section>

        <section>
            <h2>4Ô∏è‚É£ Code Generation</h2>
            <pre><code>
nest generate module users
rails generate model
            </code></pre>
        </section>

        <section>
            <h2>5Ô∏è‚É£ Internal Company Tools</h2>
            <p>Example:</p>
            <pre><code>
trycastanet sync-users
trycastanet seed-db
            </code></pre>

            <p>Useful for:</p>
            <ul>
                <li>Admin tasks</li>
                <li>Migration scripts</li>
                <li>Maintenance jobs</li>
            </ul>
        </section>

        <section>
            <h2>9. CLI Output Best Practices</h2>
            <p>Colors & formatting</p>
            <pre><code>
npm install chalk
            </code></pre>
            <pre><code>
const chalk = require("chalk");
console.log(chalk.green("Success"));
console.log(chalk.red("Error"));
            </code></pre>

            <p>Exit codes</p>
            <pre><code>
process.exit(0); // success
process.exit(1); // error
            </code></pre>
            <p>Used by CI/CD pipelines.</p>
        </section>

        <section>
            <h2>10. When NOT to Use CLI</h2>
            <p>‚ùå End-user consumer apps</p>
            <p>‚ùå Visual-heavy workflows</p>
            <p>‚ùå Non-technical users</p>

            <p>CLI is best for developers, ops, automation.</p>
        </section>
        
        <section>
            <h2>11. Typical CLI Project Structure</h2>
            <pre><code>
mycli/
 ‚îú‚îÄ bin/
 ‚îÇ   ‚îî‚îÄ mycli.js
 ‚îú‚îÄ commands/
 ‚îÇ   ‚îú‚îÄ deploy.js
 ‚îÇ   ‚îî‚îÄ init.js
 ‚îú‚îÄ utils/
 ‚îî‚îÄ package.json
            </code></pre>
        </section>

        <section>
            <h2>12. Summary</h2>
            <p>CLI is ideal when you need:</p>
            <ul>
                <li>Speed</li>
                <li>Automation</li>
                <li>Scriptability</li>
                <li>Server-side execution</li>
            </ul>

            <p>Core concepts to remember:</p>
            <ul>
                <li>Commands + arguments + flags</li>
                <li>Parsing input</li>
                <li>Executing logic</li>
                <li>Returning output & exit codes</li>
            </ul>

            <p>If you want, I can:</p>
            <ul>
                <li>Build a real CLI example for AWS / Firebase / Serverless</li>
                <li>Show React Native‚Äìrelated CLI tooling</li>
                <li>Explain how to publish a CLI to npm</li>
                <li>Compare CLI vs REST vs GUI tools</li>
            </ul>
        </section>
    </main>

    <footer>
        <p class="copyright">
            &copy; <span id="year"></span> Aether Corp. All rights reserved.
        </p>
    </footer>
</body>
</html>
