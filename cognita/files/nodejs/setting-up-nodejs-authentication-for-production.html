<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Setting up Node.js authentication for production</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../index.js"></script>
</head>
<body>
    <header>
        <nav class="corporate-nav">
            <div class="nav-container">
                <div class="title-header">
                    <h1 class="title">Setting up Node.js authentication for production</h1>
                    <p class="subtitle">Setting up Node.js authentication for production requires a solid, secure, and scalable approach. Here's a high-level guide covering best practices and components typically involved, along with some sample code snippets.</p>
                </div>        
            </div>
        </nav>
    </header>

    <main>
        <section>
            <h2>Key Considerations for Production-Ready Node.js Authentication</h2>
            <ol>
                <li>
                    Use HTTPS
                    <p>Always use HTTPS in production to protect data in transit.</p>
                </li>
                <li>
                    Secure Password Storage
                    <p>Store passwords hashed with a strong algorithm like bcrypt.</p>
                </li>
                <li>
                    Use JWT or Sessions
                    <p>Choose between stateless JWT or stateful session-based authentication.</p>
                </li>
                <li>
                    Implement Rate Limiting and Brute Force Protection
                    <p>Protect endpoints from brute force attacks.</p>
                </li>
                <li>
                    Use Environment Variables
                    <p>Secrets like JWT keys, database URIs, API keys should come from env vars.</p>
                </li>
                <li>
                    Input Validation and Sanitization
                    <p>Prevent injection attacks and other malicious inputs.</p>
                </li>
                <li>
                    Use Secure Cookies
                    <p>For sessions, cookies should be HttpOnly, Secure, and SameSite.</p>
                </li>
                <li>
                    Use a Mature Authentication Library
                    <p>Libraries like passport.js or next-auth can save time and reduce errors.</p>
                </li>
            </ol>
        </section>

        <section>
            <h2>Typical Stack for Authentication in Node.js</h2>
            <ul>
                <li>Express for server</li>
                <li>bcrypt for password hashing</li>
                <li>jsonwebtoken (JWT) for tokens OR express-session + connect-redis for session store</li>
                <li>passport.js for strategies (optional)</li>
                <li>MongoDB/PostgreSQL for user storage</li>
                <li>dotenv for environment variables</li>
            </ul>
        </section>

        <section>
            <h2>Example: JWT-Based Authentication (Express + bcrypt + jsonwebtoken)</h2>
            <ol>
                <li>
                    Setup packages
                    <pre><code>
npm install express bcrypt jsonwebtoken dotenv
                    </code></pre>
                </li>

                <li>
                    Basic code
                    <pre><code>
require('dotenv').config();
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
app.use(express.json());

const users = []; // In production, use DB

const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret';

// Register
app.post('/register', async (req, res) => {
  const { username, password } = req.body;

  if (users.find(u => u.username === username)) {
    return res.status(400).json({ message: 'User already exists' });
  }

  const hashedPassword = await bcrypt.hash(password, 10);
  users.push({ username, password: hashedPassword });

  res.status(201).json({ message: 'User registered' });
});

// Login
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username);

  if (!user) return res.status(400).json({ message: 'Invalid credentials' });

  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) return res.status(400).json({ message: 'Invalid credentials' });

  const token = jwt.sign({ username }, JWT_SECRET, { expiresIn: '1h' });

  res.json({ token });
});

// Middleware to protect routes
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.sendStatus(401);

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

// Protected route example
app.get('/profile', authenticateToken, (req, res) => {
  res.json({ message: `Welcome ${req.user.username}` });
});

app.listen(3000, () => console.log('Server running on port 3000'));
                    </code></pre>
                </li>
            </ol>
        </section>

        <section>
            <h2>Production Tips</h2>
            <ol>
                <li>Replace in-memory users array with a real database.</li>
                <li>Use HTTPS with a valid SSL cert.</li>
                <li>Store JWT secret and other secrets securely (env vars, vaults).</li>
                <li>Use refresh tokens to manage long-lived sessions securely.</li>
                <li>Add rate limiting middleware (e.g., express-rate-limit) to /login.</li>
                <li>Use Helmet (npm install helmet) for security headers.</li>
                <li>Monitor auth endpoints for suspicious activity.</li>
            </ol>
        </section>

        <section>
            <h2>Alternative: Session-Based Authentication</h2>
            <p>For session-based auth, use express-session with a persistent store like Redis:</p>
            <pre><code>
npm install express-session connect-redis redis
            </code></pre>
            <p>Then configure your app to store sessions in Redis with cookies.</p>
        </section>

        <section>
            <p>Great question! Both sessions stored in Redis and JWT-based authentication are popular ways to manage user authentication in Node.js apps, but they have different characteristics, trade-offs, and use cases. Here's a detailed comparison:</p>
            <h2>1. Storage Location</h2>

            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Sessions in Redis</th>
                        <th>JWT Authentication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Where data lives</td>
                        <td>Server-side (in Redis, an in-memory DB)</td>
                        <td>Client-side (token stored in browser)</td>
                    </tr>
                    <tr>
                        <td>Server load</td>
                        <td>Server keeps track of all active sessions</td>
                        <td>Server stateless; no session storage needed</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>2. How It Works</h2>
            <ul>
                <li>
                    Redis Sessions:
                    <p>When a user logs in, server creates a session ID and stores session data (like user ID, permissions) in Redis. The session ID is sent to client in a cookie. On subsequent requests, client sends cookie; server checks Redis for the session data.</p>
                </li>
                <li>
                    JWT:
                    <p>Server creates a JWT (JSON Web Token) containing user info (claims), signs it with a secret, and sends it to the client (usually stored in localStorage or cookie). Client sends token in Authorization header or cookie. Server verifies signature and reads claims directly from token without looking up anything.</p>
                </li>
            </ul>
        </section>

        <section>
            <h2>3. Statefulness</h2>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Redis Sessions</th>
                        <th>JWT</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>State</td>
                        <td>Stateful (server stores session data)</td>
                        <td>Stateless (server does not store sessions)</td>
                    </tr>
                    <tr>
                        <td>Scalability</td>
                        <td>Requires shared session store (Redis) across servers</td>
                        <td>Easily scales horizontally; any server can verify token</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>4. Security</h2>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Redis Sessions</th>
                        <th>JWT</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Revocation</td>
                        <td>Easy: delete session from Redis</td>
                        <td>Hard: tokens are valid until expiry; must implement blacklist or short expiry</td>
                    </tr>
                    <tr>
                        <td>Token theft impact</td>
                        <td>Stealing session ID can give access</td>
                        <td>Stealing JWT can give access until token expires</td>
                    </tr>
                    <tr>
                        <td>Storage risks</td>
                        <td>Session ID usually stored in HttpOnly, Secure cookies (safer)</td>
                        <td>JWT often stored in localStorage (vulnerable to XSS); cookies can be used with HttpOnly flag to improve security</td>
                    </tr>
                    <tr>
                        <td>Token size</td>
                        <td>Session ID small</td>
                        <td>JWT usually larger, can include user info</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>5. Performance</h2>
            <ul>
                <li>Redis sessions require a roundtrip to Redis on every authenticated request (network call).</li>
                <li>JWT auth requires just verifying the token locally (cryptographic signature verification), which is typically faster and avoids a DB or cache hit.</li>
            </ul>
        </section>

        <section>
            <h2>6. Use Cases</h2>
            <table>
                <thead>
                    <tr>
                        <th>Use Case</th>
                        <th>Redis Sessions</th>
                        <th>JWT Authentication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Traditional web apps with server-side rendering and session-based auth</td>
                        <td>✔️</td>
                        <td>❌ (less common)</td>
                    </tr>
                    <tr>
                        <td>APIs and SPAs (Single Page Apps) requiring stateless, scalable auth</td>
                        <td>❌ (possible but less ideal)</td>
                        <td>✔️</td>
                    </tr>
                    <tr>
                        <td>Need to easily revoke tokens or logout users immediately</td>
                        <td>✔️</td>
                        <td>More complicated, requires blacklist or short expiry</td>
                    </tr>
                    <tr>
                        <td>Large-scale distributed systems where statelessness is preferred</td>
                        <td>❌</td>
                        <td>✔️</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Summary Table</h2>
            <table>
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Redis Sessions</th>
                        <th>JWT Authentication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Storage</td>
                        <td>Server-side (Redis)</td>
                        <td>Client-side (token)</td>
                    </tr>
                    <tr>
                        <td>State</td>
                        <td>Stateful</td>
                        <td>Stateless</td>
                    </tr>
                    <tr>
                        <td>Revocation</td>
                        <td>Easy (delete session)</td>
                        <td>Difficult (token valid until expiry)</td>
                    </tr>
                    <tr>
                        <td>Scalability</td>
                        <td>Requires shared Redis store</td>
                        <td>Easier to scale horizontally</td>
                    </tr>
                    <tr>
                        <td>Performance</td>
                        <td>Redis lookup each request</td>
                        <td>Token verified locally</td>
                    </tr>
                    <tr>
                        <td>Token Size</td>
                        <td>Small (session ID)</td>
                        <td>Larger (JWT with claims)</td>
                    </tr>
                    <tr>
                        <td>Security Storage</td>
                        <td>HttpOnly, Secure cookies recommended</td>
                        <td>LocalStorage (XSS risk) or HttpOnly cookie</td>
                    </tr>
                    <tr>
                        <td>Use Case</td>
                        <td>Traditional web apps</td>
                        <td>APIs, SPAs</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Which one to choose?</h2>
            <ul>
                <li>
                    Use Redis sessions if:
                    <p>You want simple, easily revocable sessions and don't mind maintaining session storage; typical in traditional web apps with server-side rendered pages.</p>
                </li>
                <li>
                    Use JWT if:
                    <p>You want stateless, scalable authentication ideal for APIs or SPAs; but you need to design token expiry and revocation carefully.</p>
                </li>
            </ul>
        </section>

        <section>
            <p>Here’s a quick outline of common Node.js authentication approaches:</p>
            <h2>1. Session-Based Authentication (using Express + Passport.js)</h2>
            <ul>
                <li>User logs in with username/password.</li>
                <li>Server creates a session stored on the server and sends a session cookie to the client.</li>
                <li>Subsequent requests use the cookie to validate the user.</li>
            </ul>

            <h2>2. Token-Based Authentication (JWT)</h2>
            <ul>
                <li>User logs in and receives a signed JSON Web Token.</li>
                <li>Client stores the token (usually in localStorage or cookies).</li>
                <li>Client sends token with each request (usually in Authorization header).</li>
                <li>Server verifies the token for authentication.</li>
            </ul>
        </section>

        <section>
            <h2>Quick JWT example with Node.js and Express:</h2>
            <pre><code>
const express = require('express');
const jwt = require('jsonwebtoken');
const bodyParser = require('body-parser');

const app = express();
app.use(bodyParser.json());

const SECRET_KEY = 'your-secret-key';

const users = [{ id: 1, username: 'user1', password: 'pass1' }];

// Login route
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username && u.password === password);
  if (user) {
    // Generate JWT
    const token = jwt.sign({ userId: user.id }, SECRET_KEY, { expiresIn: '1h' });
    return res.json({ token });
  }
  res.status(401).send('Invalid credentials');
});

// Middleware to protect routes
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.sendStatus(401);

  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

// Protected route
app.get('/protected', authenticateToken, (req, res) => {
  res.send('This is protected data.');
});

app.listen(3000, () => console.log('Server running on port 3000'));

            </code></pre>
        </section>
    </main>

    <footer>
        <p class="copyright">
            &copy; <span id="year"></span> Aether Corp. All rights reserved.
        </p>
    </footer>
</body>
</html>
