<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Microservices</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../index.js"></script>
</head>
<body>
    <header>
        <nav class="corporate-nav">
            <div class="nav-container">
                <div class="title-header">
                    <h1 class="title">Microservices</h1>
                    <p class="subtitle">Microservices are a software architectural style that structures an application as a collection of small, autonomous services modeled around a business domain. This approach offers flexibility, scalability, and ease of deployment but also introduces complexity in design, communication, and management.</p>
                </div>        
            </div>
        </nav>
    </header>

    <main>
        <section>
            <p>Here‚Äôs an overview of Microservices usage and implementation:</p>
            <h2>üîç WHAT ARE MICROSERVICES?</h2>
            <p>Definition:</p>
            <p>A microservice is a small, independently deployable service that performs a specific business function and communicates with other services through APIs (often REST or messaging queues).</p>
        </section>

        <section>
            <h2>‚úÖ USE CASES & BENEFITS OF MICROSERVICES</h2>
            <table>
                <thead>
                    <tr>
                        <th>Use Case</th>
                        <th>Benefit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Large-scale applications</td>
                        <td>Easier to scale individual components</td>
                    </tr>
                    <tr>
                        <td>Frequent updates/releases</td>
                        <td>Enables faster deployments and CI/CD</td>
                    </tr>
                    <tr>
                        <td>Multiple teams working independently</td>
                        <td>Teams can own and deploy their own services</td>
                    </tr>
                    <tr>
                        <td>Polyglot programming</td>
                        <td>Each service can use a different tech stack</td>
                    </tr>
                    <tr>
                        <td>Fault isolation</td>
                        <td>A failure in one service doesn't bring down the whole system</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>üõ†Ô∏è HOW TO IMPLEMENT MICROSERVICES</h2>
            <p>1. Design Principles</p>
            <ul>
                <li>Single Responsibility: Each service does one thing well.</li>
                <li>Bounded Context: Define clear boundaries using Domain-Driven Design (DDD).</li>
                <li>Loose Coupling & High Cohesion: Services should be loosely coupled and internally cohesive.</li>
                <li>Database per Service: Avoid sharing databases between services.</li>
            </ul>
        </section>

        <section>
            <h2>2. Tech Stack Components</h2>
            <table>
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Examples</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Programming Language</td>
                        <td>Java, .NET, Node.js, Python, Go</td>
                    </tr>
                    <tr>
                        <td>API Communication</td>
                        <td>REST, gRPC, GraphQL</td>
                    </tr>
                    <tr>
                        <td>Data Storage</td>
                        <td>MySQL, PostgreSQL, MongoDB, Cassandra</td>
                    </tr>
                    <tr>
                        <td>Service Discovery</td>
                        <td>Netflix Eureka, Consul, Kubernetes DNS</td>
                    </tr>
                    <tr>
                        <td>API Gateway</td>
                        <td>Kong, Istio, NGINX, Spring Cloud Gateway</td>
                    </tr>
                    <tr>
                        <td>Containerization</td>
                        <td>Docker</td>
                    </tr>
                    <tr>
                        <td>Orchestration</td>
                        <td>Kubernetes, Docker Swarm</td>
                    </tr>
                    <tr>
                        <td>Monitoring & Logging</td>
                        <td>Prometheus, Grafana, ELK Stack, Jaeger</td>
                    </tr>
                    <tr>
                        <td>Security</td>
                        <td>OAuth2, JWT, mTLS, API Keys</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>3. Common Patterns</h2>
            <table>
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>API Gateway</td>
                        <td>Central entry point for requests, handles routing, auth, etc.</td>
                    </tr>
                    <tr>
                        <td>Service Discovery</td>
                        <td>Services locate each other dynamically</td>
                    </tr>
                    <tr>
                        <td>Circuit Breaker</td>
                        <td>Prevent cascading failures (e.g., Netflix Hystrix)</td>
                    </tr>
                    <tr>
                        <td>Bulkhead</td>
                        <td>Isolate failures within components</td>
                    </tr>
                    <tr>
                        <td>Sidecar</td>
                        <td>A helper process that enhances service features (e.g., Istio/Envoy proxy)</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>4. Steps to Implement Microservices</h2>
            <p>Step 1: Decompose the Monolith</p>
            <ul>
                <li>Identify modules or bounded contexts.</li>
                <li>Convert them to standalone services.</li>
            </ul>
        </section>

        <section>
            <h2>Step 2: Define Service Contracts</h2>
            <ul>
                <li>Use OpenAPI/Swagger to define interfaces.</li>
            </ul>
        </section>

        <section>
            <h2>Step 3: Implement and Test Services</h2>
            <ul>
                <li>Unit test, integration test, and contract test each service.</li>
            </ul>
        </section>

        <section>
            <h2>Step 4: Deploy with CI/CD</h2>
            <ul>
                <li>Use Jenkins, GitHub Actions, or GitLab CI for automation.</li>
                <li>Package services with Docker and deploy to Kubernetes.</li>
            </ul>
        </section>

        <section>
            <h2>Step 5: Monitor and Secure</h2>
            <ul>
                <li>Implement logging, tracing, and metrics.</li>
                <li>Secure APIs using OAuth2/JWT.</li>
            </ul>
        </section>

        <section>
            <h2>‚ö†Ô∏è CHALLENGES</h2>
            <ul>
                <li>Distributed Complexity: Harder to debug and trace across services.</li>
                <li>Data Management: Managing transactions across services (saga pattern).</li>
                <li>Latency & Network Failures: Services depend on reliable network calls.</li>
                <li>Deployment Overhead: More services = more operational overhead.</li>
            </ul>
        </section>

        <section>
            <h2>üìå EXAMPLE ARCHITECTURE</h2>
            <pre><code>
        +-------------+        +---------------+
        |  API Gateway|------->| Auth Service  |
        +-------------+        +---------------+
                |                      |
                v                      v
        +------------------+   +-----------------+
        | User Service     |   | Order Service   |
        +------------------+   +-----------------+
                    \               /
                    \             /
                    +---------------+
                    | Payment Service|
                    +---------------+

All services have:
- Separate databases
- Containerized (Docker)
- Deployed to Kubernetes
- Monitored via Prometheus        
            </code></pre>
        </section>

        <section>
            <h2>üß† BEST PRACTICES</h2>
            <ul>
                <li>Keep services small and focused.</li>
                <li>Automate everything (builds, tests, deployments).</li>
                <li>Implement observability from the beginning.</li>
                <li>Handle failures gracefully (timeouts, retries, circuit breakers).</li>
                <li>Design for eventual consistency when needed.</li>
            </ul>
        </section>
    </main>

    <footer>
        <p class="copyright">
            &copy; <span id="year"></span> Aether Corp. All rights reserved.
        </p>
    </footer>
</body>
</html>
